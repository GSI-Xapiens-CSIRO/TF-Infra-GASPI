#!/bin/bash
# /usr/local/bin/atlantis-deploy

set -euo pipefail

# ============================================================================
# ATLANTIS SYSTEM-WIDE DEPLOYMENT SCRIPT
# Location: /usr/local/bin/atlantis-deploy
# Usage: atlantis-deploy <environment> [plan|apply]
# ============================================================================

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

# Logging functions
log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; }

# Script metadata
SCRIPT_VERSION="1.0.3"
SCRIPT_NAME="atlantis-deploy"
SCRIPT_AUTHOR="GXC DevOps-Team"
SCRIPT_COMPANY="GXC Consortium"
SCRIPT_LICENSE="Apache v2"
SCRIPT_DATE="May, 2025"

# Display logo and version
show_logo() {
    cat << 'EOF'

        __  .__                 __  .__
_____ _/  |_|  | _____    _____/  |_|__| ______
\__  \\   __\  | \__  \  /    \   __\  |/  ___/
 / __ \|  | |  |__/ __ \|   |  \  | |  |\___ \
(____  /__| |____(____  /___|  /__| |__/____  >
     \/               \/     \/             \/
     .___            .__
   __| _/____ ______ |  |   ____ ___.__.
  / __ |/ __ \\____ \|  |  /  _ <   |  |
 / /_/ \  ___/|  |_> >  |_(  <_> )___  |
 \____ |\___  >   __/|____/\____// ____|
      \/    \/|__|               \/

EOF

    echo "================================================================"
    echo "    Atlantis Schema Deploy - Infrastructure as Code"
    echo "================================================================"
    echo "Version    : $SCRIPT_VERSION"
    echo "Author     : $SCRIPT_AUTHOR"
    echo "Company    : $SCRIPT_COMPANY"
    echo "Build      : $SCRIPT_DATE"
    echo "License    : $SCRIPT_LICENSE"
    echo "================================================================"
    echo ""
}

# Show version info
show_version() {
    show_logo
    echo -e "${GREEN}$SCRIPT_NAME version $SCRIPT_VERSION${NC}"
    echo -e "${BLUE}Build for Terraform Infrastructure Automation${NC}"
    echo -e "${BLUE}Supports environments: hub01-04, uat01-04${NC}"
    echo ""
}

# Show help
show_help() {
    show_logo
    cat << EOF
USAGE:
    $SCRIPT_NAME <environment> [operation]

ARGUMENTS:
    environment    Target environment (hub01, hub02, hub03, hub04, uat01, uat02, uat03, uat04)
    operation      Operation to perform (plan, apply) [default: plan]

EXAMPLES:
    $SCRIPT_NAME hub01 plan          # Plan deployment for hub01
    $SCRIPT_NAME uat02 apply         # Apply deployment for uat02
    $SCRIPT_NAME hub03               # Plan deployment for hub03 (default)

ENVIRONMENT VARIABLES:
    GITHUB_TOKEN                     Required: GitHub Personal Access Token
    GIT_USER_NAME                    Git commit author name (default: DevOps XTI)
    GIT_USER_EMAIL                   Git commit author email (default: devops@xapiens.id)
    GITHUB_USERNAME                  GitHub username for authentication (default: devopsxti)
    ATLANTIS_CONFIG_PATH             Config path (default: /atlantis/config)
    ATLANTIS_WORKSPACE               Current workspace directory
    ATLANTIS_PROJECT_NAME            Current project name
    ATLANTIS_PULL_REQUEST_HEAD_BRANCH Current branch name

SUPPORTED ENVIRONMENTS:
    HUB environments: hub01, hub02, hub03, hub04
    UAT environments: uat01, uat02, uat03, uat04

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information

EOF
}

# Parse command line arguments
parse_arguments() {
    case ${1:-} in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        "")
            show_logo
            log_error "Environment argument is required"
            echo ""
            echo -e "${YELLOW}Usage: $SCRIPT_NAME <environment> [operation]${NC}"
            echo -e "${YELLOW}Try '$SCRIPT_NAME --help' for more information.${NC}"
            exit 1
            ;;
        *)
            ENVIRONMENT="$1"
            OPERATION="${2:-plan}"
            ;;
    esac
}

# Validate environment
validate_environment() {
    case $ENVIRONMENT in
        hub01|hub02|hub03|hub04|uat01|uat02|uat03|uat04)
            log_info "Processing $OPERATION for environment: $ENVIRONMENT"
            ;;
        *)
            log_error "Unsupported environment: $ENVIRONMENT"
            echo "Supported environments: hub01-04, uat01-04"
            exit 1
            ;;
    esac
}

# Set environment-specific variables
setup_environment_variables() {
    # Environment type and number
    ENV_TYPE=$(echo $ENVIRONMENT | sed 's/[0-9]*$//')
    ENV_NUMBER=$(echo $ENVIRONMENT | sed 's/^[a-z]*//')

    # AWS Profile
    AWS_PROFILE="GXC-TF-User-Executor-${ENVIRONMENT^^}"

    # Configuration paths
    CONFIG_BASE_PATH="${ATLANTIS_CONFIG_PATH:-/atlantis/config}"
    CONFIG_PATH="${CONFIG_BASE_PATH}/${ENVIRONMENT}"

    # Git configuration
    GIT_USER_NAME="${GIT_USER_NAME:-DevOps XTI}"           # Display name for commits
    GIT_USER_EMAIL="${GIT_USER_EMAIL:-devops@xapiens.id}"  # Email for commits
    GITHUB_USERNAME="${GITHUB_USERNAME:-devopsxti}"        # Actual GitHub username for auth

    log_info "Environment Type: $ENV_TYPE, Number: $ENV_NUMBER"
    log_info "AWS Profile: $AWS_PROFILE"
    log_info "Config Path: $CONFIG_PATH"
}

# Validate prerequisites
validate_prerequisites() {
    log_info "Validating prerequisites..."

    # Check required commands
    local required_commands=("git" "aws" "terraform")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done

    # Check GitHub token
    if [ -z "${GITHUB_TOKEN:-}" ]; then
        log_error "GITHUB_TOKEN environment variable is required"
        exit 1
    fi

    # Check configuration directory
    if [ ! -d "$CONFIG_PATH" ]; then
        log_error "Configuration directory not found: $CONFIG_PATH"
        exit 1
    fi

    log_success "Prerequisites validated"
}

# Fix Git configuration permissions
fix_git_permissions() {
    local git_config_file="$HOME/.gitconfig"
    local git_config_dir="$(dirname "$git_config_file")"
    local git_config_global_dir="$HOME/.config/git"

    log_info "Checking Git configuration permissions"
    log_info "Current user: $(whoami) ($(id))"
    log_info "Home directory: $HOME"

    # Ensure the home directory exists and has proper permissions
    if [ ! -d "$HOME" ]; then
        log_error "Home directory $HOME does not exist"
        exit 1
    fi

    # Check if we can write to home directory
    if [ ! -w "$HOME" ]; then
        log_error "Cannot write to home directory: $HOME"
        log_error "Directory permissions: $(ls -ld "$HOME")"
        exit 1
    fi

    # Remove existing .gitconfig if it has wrong permissions
    if [ -f "$git_config_file" ] && [ ! -w "$git_config_file" ]; then
        log_warning "Removing non-writable .gitconfig file"
        rm -f "$git_config_file" 2>/dev/null || {
            log_error "Cannot remove .gitconfig file with wrong permissions"
            log_error "File permissions: $(ls -l "$git_config_file")"
            # Force use local config
            GIT_CONFIG_SCOPE="--local"
            return 0
        }
    fi

    # Create new .gitconfig with proper permissions
    if [ ! -f "$git_config_file" ]; then
        touch "$git_config_file" && chmod 644 "$git_config_file"
    fi

    # Test if we can write to .gitconfig
    if [ -w "$git_config_file" ]; then
        GIT_CONFIG_SCOPE="--global"
        log_success "Using global Git configuration"
    else
        log_warning "Cannot write to $git_config_file, will use local git config only"
        GIT_CONFIG_SCOPE="--local"
    fi
}

# Setup Git configuration
setup_git_config() {
    log_info "Setting up Git configuration"

    # Fix permissions first
    fix_git_permissions

    # Configure git with appropriate scope
    git config $GIT_CONFIG_SCOPE user.name "$GIT_USER_NAME" || {
        log_warning "Failed to set global git config, trying local config"
        git config --local user.name "$GIT_USER_NAME"
        git config --local user.email "$GIT_USER_EMAIL"
        git config --local init.defaultBranch main
        git config --local pull.rebase false
        log_success "Git configuration completed (local scope)"
        return 0
    }

    git config $GIT_CONFIG_SCOPE user.email "$GIT_USER_EMAIL"
    git config $GIT_CONFIG_SCOPE init.defaultBranch main
    git config $GIT_CONFIG_SCOPE pull.rebase false

    log_success "Git configuration completed (global scope)"
}

# Setup GitHub authentication
setup_github_auth() {
    log_info "Configuring GitHub authentication"

    # Configure GitHub authentication using URL rewriting
    # Try global first, fall back to local if needed
    if ! git config --global url."https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/" 2>/dev/null; then
        log_warning "Failed to set global GitHub auth, using local config"
        git config --local url."https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
    fi

    log_success "GitHub authentication configured"
}

# Test GitHub access
test_github_access() {
    log_info "Testing GitHub repository access"

    local test_repo="GSI-Xapiens-CSIRO/report_templates"
    local timeout_duration=30

    if timeout $timeout_duration git ls-remote --exit-code "https://github.com/${test_repo}.git" > /dev/null 2>&1; then
        log_success "GitHub repository access confirmed"
    else
        log_error "Failed to access GitHub repository: $test_repo"
        log_error "Check if $GITHUB_USERNAME has access to the repository"
        exit 1
    fi
}

# Setup AWS credentials
setup_aws_credentials() {
    log_info "Setting up AWS credentials for profile: $AWS_PROFILE"

    # Clean existing credentials
    unset AWS_SESSION_TOKEN AWS_SECRET_ACCESS_KEY AWS_ACCESS_KEY_ID AWS_SECURITY_TOKEN

    # Set AWS profile and region
    export AWS_PROFILE="$AWS_PROFILE"

    # Verify AWS access
    if aws sts get-caller-identity --output table > /dev/null 2>&1; then
        local account_id=$(aws sts get-caller-identity --query Account --output text)
        local caller_arn=$(aws sts get-caller-identity --query Arn --output text)

        log_success "AWS authenticated successfully"
        log_info "Account ID: $account_id"
        log_info "Caller ARN: $(basename $caller_arn)"
    else
        log_error "AWS authentication failed for profile: $AWS_PROFILE"
        exit 1
    fi
}

# Initialize Git submodules
initialize_submodules() {
    log_info "Initializing Git submodules"

    if git submodule update --init --recursive --progress; then
        log_success "All submodules initialized successfully"

        # Show submodule status
        log_info "Submodule status:"
        git submodule status --recursive
    else
        log_error "Submodule initialization failed"
        log_info "Current submodule status:"
        git submodule status --recursive || true
        exit 1
    fi
}

# Setup Terraform configuration
setup_terraform_config() {
    log_info "Setting up Terraform configuration for $ENVIRONMENT"

    # Configuration file paths
    local backend_tf="${CONFIG_PATH}/backend.tf"
    local backend_tfvars="${CONFIG_PATH}/backend.tfvars"
    local terraform_tfvars="${CONFIG_PATH}/${ENVIRONMENT}.tfvars"

    # Check if configuration files exist
    local files=("$backend_tf" "$backend_tfvars" "$terraform_tfvars")

    for file in "${files[@]}"; do
        if [ ! -f "$file" ]; then
            log_error "Configuration file not found: $file"
            exit 1
        fi
    done

    # Copy configuration files to current directory
    cp "$backend_tf" .
    cp "$backend_tfvars" .
    cp "$terraform_tfvars" .

    log_success "Configuration files copied:"
    log_info "- backend.tf"
    log_info "- backend.tfvars"
    log_info "- ${ENVIRONMENT}.tfvars"
}

# Run initialization script
run_initialization_script() {
    log_info "Running environment initialization scripts"

    local current_dir=$(pwd)
    local init_script="./init.sh"

    log_info "Current working directory: $current_dir"

    # Check if main init.sh exists in current directory
    if [ -f "$init_script" ]; then
        log_info "Found init.sh in current directory"

        # Check if script is executable, make it executable if needed
        if [ ! -x "$init_script" ]; then
            log_info "Making init.sh executable"
            chmod +x "$init_script" || {
                log_error "Failed to make init.sh executable"
                exit 1
            }
        fi

        # Execute the script
        log_info "Executing init.sh"
        if bash "$init_script"; then
            log_success "Successfully executed init.sh"
        else
            log_error "Failed to execute init.sh"
            exit 1
        fi
    else
        log_warning "init.sh not found in current directory: $current_dir"
        log_info "Checking if this is expected for this project structure..."

        # List contents to help with debugging
        log_info "Directory contents:"
        ls -la . || true
    fi
}

# Initialize Terraform
initialize_terraform() {
    log_info "Initializing Terraform"

    # Check Terraform version
    local current_version=$(terraform version -json | jq -r '.terraform_version' 2>/dev/null || echo "unknown")
    log_info "Terraform version: $current_version"

    # Initialize Terraform
    if terraform init -backend-config=backend.tfvars -upgrade -input=false; then
        log_success "Terraform initialized successfully"
    else
        log_error "Terraform initialization failed"
        exit 1
    fi
}

# Create Terraform plan
terraform_plan() {
    log_info "Creating Terraform plan for $ENVIRONMENT"

    local plan_file="${ENVIRONMENT}-plan.out"

    if terraform plan -var-file="${ENVIRONMENT}.tfvars" -out="$plan_file" -input=false; then
        log_success "Terraform plan created successfully: $plan_file"

        # Show plan summary
        log_info "Plan summary:"
        terraform show -no-color "$plan_file" | head -20
    else
        log_error "Terraform plan creation failed"
        exit 1
    fi
}

# Apply Terraform
terraform_apply() {
    log_info "Applying Terraform for $ENVIRONMENT"

    if terraform apply -var-file="${ENVIRONMENT}.tfvars" -auto-approve -input=false; then
        log_success "Terraform apply completed successfully"
    else
        log_error "Terraform apply failed"
        exit 1
    fi
}

# Cleanup sensitive files
cleanup_sensitive_files() {
    log_info "Cleaning up sensitive files"

    # Remove credentials file if it exists
    [ -f ~/.git-credentials ] && rm -f ~/.git-credentials

    # Clear Git credential cache (ignore errors)
    git config --global --unset credential.helper 2>/dev/null || true
    git config --local --unset credential.helper 2>/dev/null || true

    log_success "Cleanup completed"
}

# Main execution function
main() {
    show_logo
    log_info "Starting Atlantis $OPERATION for environment: $ENVIRONMENT"
    log_info "============================================================"

    # Setup phase
    validate_prerequisites
    setup_environment_variables
    setup_git_config
    setup_github_auth
    test_github_access
    setup_aws_credentials

    # Repository initialization
    initialize_submodules
    setup_terraform_config

    # Init submodules
    run_initialization_script

    # Terraform operations
    initialize_terraform

    case $OPERATION in
        "plan")
            terraform_plan
            ;;
        "apply")
            terraform_apply
            ;;
        *)
            log_error "Unsupported operation: $OPERATION"
            echo "Supported operations: plan, apply"
            exit 1
            ;;
    esac

    # Cleanup
    cleanup_sensitive_files

    log_success "============================================================"
    log_success "Atlantis $OPERATION completed successfully for $ENVIRONMENT!"
    echo ""
    echo -e "${CYAN}${BOLD}Thank you for using Atlantis Schema Deploy${NC}"
    echo -e "${BLUE}© $SCRIPT_DATE $SCRIPT_COMPANY${NC}"
}

# Parse arguments
parse_arguments "$@"

# Validate environment
validate_environment

# Trap to ensure cleanup on exit
trap cleanup_sensitive_files EXIT

# Execute main function
main